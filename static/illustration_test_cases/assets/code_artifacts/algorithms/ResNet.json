{
  "Train": [
    "# Model Training\n",
    "# Algo/ResNet\n",
    "\n",
    "def build_resnet(input_shape, n_feature_maps, nb_classes):\n",
    "    x = keras.layers.Input(shape=(input_shape))\n",
    "    conv_x = keras.layers.BatchNormalization()(x)\n",
    "    conv_x = keras.layers.Conv2D(n_feature_maps, 8, 1, padding='same')(conv_x)\n",
    "    conv_x = keras.layers.BatchNormalization()(conv_x)\n",
    "    conv_x = keras.layers.Activation('relu')(conv_x)\n",
    "\n",
    "    conv_y = keras.layers.Conv2D(n_feature_maps, 5, 1, padding='same')(conv_x)\n",
    "    conv_y = keras.layers.BatchNormalization()(conv_y)\n",
    "    conv_y = keras.layers.Activation('relu')(conv_y)\n",
    "\n",
    "    conv_z = keras.layers.Conv2D(n_feature_maps, 3, 1, padding='same')(conv_y)\n",
    "    conv_z = keras.layers.BatchNormalization()(conv_z)\n",

    "    is_expand_channels = not (input_shape[-1] == n_feature_maps)\n",
    "    if is_expand_channels:\n",
    "        shortcut_y = keras.layers.Conv2D(n_feature_maps, 1, 1,padding='same')(x)\n",
    "        shortcut_y = keras.layers.BatchNormalization()(shortcut_y)\n",
    "    else:\n",
    "        shortcut_y = keras.layers.BatchNormalization()(x)\n",
    "    y = keras.layers.Add()([shortcut_y, conv_z])\n",
    "    y = keras.layers.Activation('relu')(y)\n",
    "\n",
    "    x1 = y\n",
    "    conv_x = keras.layers.Conv2D(n_feature_maps*2, 8, 1, padding='same')(x1)\n",
    "    conv_x = keras.layers.BatchNormalization()(conv_x)\n",
    "    conv_x = keras.layers.Activation('relu')(conv_x)\n",
    "\n",
    "    conv_y = keras.layers.Conv2D(n_feature_maps*2, 5, 1, padding='same')(conv_x)\n",
    "    conv_y = keras.layers.BatchNormalization()(conv_y)\n",
    "    conv_y = keras.layers.Activation('relu')(conv_y)\n",
    "\n",
    "    conv_z = keras.layers.Conv2D(n_feature_maps*2, 3, 1, padding='same')(conv_y)\n",
    "    conv_z = keras.layers.BatchNormalization()(conv_z)\n",
    "\n",
    "    is_expand_channels = not (input_shape[-1] == n_feature_maps*2)\n",
    "    if is_expand_channels:\n",
    "        shortcut_y = keras.layers.Conv2D(n_feature_maps*2, 1, 1,padding='same')(x1)\n",
    "        shortcut_y = keras.layers.BatchNormalization()(shortcut_y)\n",
    "    else:\n",
    "        shortcut_y = keras.layers.BatchNormalization()(x1)\n",
    "    y = keras.layers.Add()([shortcut_y, conv_z])\n",
    "    y = keras.layers.Activation('relu')(y)\n",
    "\n",
    "    x1 = y\n",
    "    conv_x = keras.layers.Conv2D(n_feature_maps*2, 8, 1, padding='same')(x1)\n",
    "    conv_x = keras.layers.BatchNormalization()(conv_x)\n",
    "    conv_x = keras.layers.Activation('relu')(conv_x)\n",
    "\n",
    "    conv_y = keras.layers.Conv2D(n_feature_maps*2, 5, 1, padding='same')(conv_x)\n",
    "    conv_y = keras.layers.BatchNormalization()(conv_y)\n",
    "    conv_y = keras.layers.Activation('relu')(conv_y)\n",
    "\n",
    "    conv_z = keras.layers.Conv2D(n_feature_maps*2, 3, 1, padding='same')(conv_y)\n",
    "    conv_z = keras.layers.BatchNormalization()(conv_z)\n",
    "\n",
    "    is_expand_channels = not (input_shape[-1] == n_feature_maps*2)\n",
    "    if is_expand_channels:\n",
    "        shortcut_y = keras.layers.Conv2D(n_feature_maps*2, 1, 1,padding='same')(x1)\n",
    "        shortcut_y = keras.layers.BatchNormalization()(shortcut_y)\n",
    "    else:\n",
    "        shortcut_y = keras.layers.BatchNormalization()(x1)\n",
    "    y = keras.layers.Add()([shortcut_y, conv_z])\n",
    "    y = keras.layers.Activation('relu')(y)\n",
    "\n",
    "    full = keras.layers.GlobalAveragePooling2D()(y)\n",
    "    out = keras.layers.Dense(nb_classes, activation='softmax')(full)\n",
    "    model = keras.models.Model(inputs=x, outputs=y)\n",
    "    optimizer = keras.optimizers.Adam()\n",
    "    model.compile(loss='categorical_crossentropy', optimizer=optimizer, metrics=['accuracy'])\n",
    "    return model\n",
    "\n",
    "\n",
    "def train_model(model,X_train,y_train,X_valid,y_valid, batch_size, nb_epochs):\n",
    "    reduce_lr = keras.callbacks.ReduceLROnPlateau(monitor='loss', factor=0.5, patience=50, min_lr=0.0001)\n",
    "    return model.fit(X_train, y_train, batch_size=batch_size, nb_epoch=nb_epochs, verbose=1, validation_data=(X_valid, y_valid), callbacks = [reduce_lr])\n",
    "\n",
    "\n",
    "# parameters to complete as you want\n",
    "input_shape = ??\n",
    "n_feature_maps = ??\n",
    "nb_classes = ??\n",
    "batch_size = ??\n",
    "nb_epochs = ??\n",
    "resnet = build_resnet(input_shape, n_feature_maps, nb_classes)\n",
    "model = train_model(resnet, x_train, y_train, x_valid, y_valid, batch_size, nb_epochs)\n"
  ],
  "Valid": [
    "# Validation\n",
    "# Algo/ResNet\n",
    "\n",
    "def predict_model_valid(model, x_valid):\n",
    "    return model.predict(x_valid)\n",
    "\n",
    "valid_result = predict_model_valid(resnet, x_valid)\n"
  ],
  "Test": [
    "# Test\n",
    "# Algo/ResNet\n",
    "\n",
    "def predict_model(model, x_test):\n",
    "    return model.predict(x_test)\n",
    "\n",
    "result = predict_model(resnet, x_test)\n"
  ],
  "Imports": ["from tensorflow import keras\n", "import numpy as np\n"]
}
